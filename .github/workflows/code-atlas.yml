name: Code Atlas Analysis

on:
  push:
    branches: [main, develop]
  pull_request:
    types: [opened, reopened, labeled]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  analyze:
    # Only run on: manual trigger, PR open/reopen, or when 'run-analysis' label is added
    if: |
      github.event_name == 'push' ||
      github.event_name == 'workflow_dispatch' ||
      github.event.action == 'opened' ||
      github.event.action == 'reopened' ||
      contains(github.event.pull_request.labels.*.name, 'run-analysis')
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git metadata
      
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Link local version
        run: npm link
      
      - name: Scan codebase
        run: code-atlas scan --include-git
      
      - name: Check complexity threshold
        run: |
          MAX_COMPLEXITY=10
          ACTUAL=$(code-atlas stats --format json | jq -r '.averageComplexity // 0')
          echo "Average complexity: $ACTUAL (threshold: $MAX_COMPLEXITY)"
          if (( $(echo "$ACTUAL > $MAX_COMPLEXITY" | bc -l) )); then
            echo "âŒ Code complexity exceeds threshold!"
            exit 1
          fi
      
      - name: Generate dependency graphs
        run: |
          code-atlas graph --format mermaid --output dependency-graph.md
      
      - name: Generate HTML report
        run: code-atlas report --output code-atlas-report.html
      
      - name: Collect statistics
        id: stats
        run: |
          code-atlas stats > stats.txt
          code-atlas stats --format json > stats.json
          cat stats.txt
          
          # Extract key metrics
          TOTAL_FUNCTIONS=$(jq -r '.totalFunctions // 0' stats.json)
          AVG_COMPLEXITY=$(jq -r '.averageComplexity // 0' stats.json)
          echo "total_functions=$TOTAL_FUNCTIONS" >> $GITHUB_OUTPUT
          echo "avg_complexity=$AVG_COMPLEXITY" >> $GITHUB_OUTPUT
      
      - name: Add reports to summary
        if: always()
        run: |
          echo "## ðŸ“Š Code Atlas Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat stats.txt >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f dependency-graph.md ]; then
            echo "### Dependency Graph" >> $GITHUB_STEP_SUMMARY
            cat dependency-graph.md >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: code-atlas-reports
          path: |
            code-atlas-report.html
            dependency-graph.md
            registry.json
            stats.txt
            stats.json
      
      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Verify we have a PR context
            if (!context.issue || !context.issue.number) {
              console.log('No PR context available, skipping comment');
              return;
            }
            
            console.log(`Processing PR #${context.issue.number}`);
            
            // Changes-only mode: compare base and head branches
            try {
              // Checkout base branch and scan
              execSync('git fetch origin ${{ github.base_ref }}');
              execSync('git checkout origin/${{ github.base_ref }}');
              execSync('code-atlas scan --include-git --output base-registry.json');
              
              // Checkout PR branch and scan
              execSync('git checkout ${{ github.sha }}');
              execSync('code-atlas scan --include-git --output head-registry.json');
              
              // Generate diff
              execSync('code-atlas diff --base base-registry.json --head head-registry.json --format json --output pr-diff.json');
              
              // Check if there are changes
              if (!fs.existsSync('pr-diff.json')) {
                console.log('No function changes detected, skipping comment');
                return;
              }
              
              const diffContent = fs.readFileSync('pr-diff.json', 'utf8');
              const diff = JSON.parse(diffContent);
              const summary = diff.summary;
              
              if (summary.added === 0 && summary.modified === 0 && summary.deleted === 0) {
                console.log('No function changes detected, skipping comment');
                return;
              }
              
              // Build comment with change summary
              let comment = `## Code Atlas: Function Changes\n\n`;
              comment += `### Summary\n\n`;
              comment += `- **Added:** ${summary.added} functions\n`;
              comment += `- **Modified:** ${summary.modified} functions\n`;
              comment += `- **Deleted:** ${summary.deleted} functions\n\n`;
              
              if (summary.complexityIncreases > 0) {
                comment += `**Warning:** ${summary.complexityIncreases} functions increased in complexity\n\n`;
              }
              
              if (summary.signatureChanges > 0) {
                comment += `**Warning:** ${summary.signatureChanges} functions changed signatures\n\n`;
              }
              
              // Check for duplicates in the head registry
              const headRegistry = JSON.parse(fs.readFileSync('head-registry.json', 'utf8'));
              if (headRegistry.duplicates && headRegistry.duplicates.length > 0) {
                comment += `**Warning:** ${headRegistry.duplicates.length} duplicate/near-duplicate function pairs detected\n\n`;
              }
              
              // Add top modified functions
              if (diff.modified && diff.modified.length > 0) {
                comment += `### Modified Functions\n\n`;
                comment += `| Function | File | Complexity | Change |\n`;
                comment += `|----------|------|------------|--------|\n`;
                diff.modified.slice(0, 10).forEach(m => {
                  const delta = m.complexityDelta > 0 ? `+${m.complexityDelta}` : m.complexityDelta < 0 ? `${m.complexityDelta}` : '0';
                  const warning = m.complexityDelta > 5 ? ' âš ï¸' : '';
                  comment += `| \`${m.name}\` | ${m.filePath} | ${m.complexityBefore} â†’ ${m.complexityAfter} | ${delta}${warning} |\n`;
                });
                if (diff.modified.length > 10) {
                  comment += `\n*... and ${diff.modified.length - 10} more*\n`;
                }
                comment += `\n`;
              }
              
              // Add top added functions
              if (diff.added && diff.added.length > 0) {
                comment += `### Added Functions\n\n`;
                comment += `| Function | File | Complexity |\n`;
                comment += `|----------|------|------------|\n`;
                diff.added.slice(0, 10).forEach(fn => {
                  comment += `| \`${fn.name}\` | ${fn.filePath} | ${fn.complexity} |\n`;
                });
                if (diff.added.length > 10) {
                  comment += `\n*... and ${diff.added.length - 10} more*\n`;
                }
                comment += `\n`;
              }
              
              // Add duplicate detection results
              if (headRegistry.duplicates && headRegistry.duplicates.length > 0) {
                comment += `### Duplicate Functions\n\n`;
                headRegistry.duplicates.slice(0, 5).forEach(dup => {
                  comment += `**${dup.function1.name}** (${dup.function1.filePath}:${dup.function1.line}) â†” **${dup.function2.name}** (${dup.function2.filePath}:${dup.function2.line})\n`;
                  comment += `- Similarity: ${(dup.similarity * 100).toFixed(1)}%\n\n`;
                });
                if (headRegistry.duplicates.length > 5) {
                  comment += `*... and ${headRegistry.duplicates.length - 5} more duplicate pairs*\n\n`;
                }
              }
              
              // Generate focused impact graph with changed functions highlighted
              const changedFunctions = [
                ...diff.added.map(f => f.name),
                ...diff.modified.map(m => m.name)
              ];
              
              if (changedFunctions.length > 0 && changedFunctions.length < 30) {
                try {
                  const addedFunctions = diff.added.map(f => f.name).join(',');
                  const modifiedFunctions = diff.modified.map(m => m.name).join(',');
                  const focusFunctions = changedFunctions.join(',');
                  
                  // Generate focused graph with highlighting
                  let graphCmd = `code-atlas graph --format mermaid --focus "${focusFunctions}" --focus-depth 1`;
                  if (addedFunctions) graphCmd += ` --highlight-added "${addedFunctions}"`;
                  if (modifiedFunctions) graphCmd += ` --highlight-modified "${modifiedFunctions}"`;
                  graphCmd += ' --output focused-graph.md';
                  
                  execSync(graphCmd);
                  
                  if (fs.existsSync('focused-graph.md')) {
                    const graphContent = fs.readFileSync('focused-graph.md', 'utf8');
                    comment += `### Impact Graph\n\n`;
                    comment += `Focused view showing changed functions and their immediate dependencies:\n\n`;
                    comment += graphContent + `\n\n`;
                    comment += `**Legend:** ðŸŸ¢ Added | ðŸŸ¡ Modified | ðŸ”µ Exported\n\n`;
                  }
                } catch (graphError) {
                  console.log('Failed to generate focused graph:', graphError.message);
                }
              }
              
              comment += `\n[View detailed reports](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})\n\n`;
              comment += `---\n`;
              comment += `**Re-run this analysis:** Add the \`run-analysis\` label or use the [Actions tab](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/workflows/code-atlas.yml) to manually trigger.\n`;
              
              // Post comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              
            } catch (error) {
              console.error('Error in changes-only mode:', error);
              // Fall back to basic comment
              const stats = fs.readFileSync('stats.txt', 'utf8');
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `## Code Atlas Analysis\n\n\`\`\`\n${stats}\`\`\``
              });
            }
